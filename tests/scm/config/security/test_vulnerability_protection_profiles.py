# tests/scm/config/security/test_vulnerability_protection_profile.py

import pytest
from unittest.mock import MagicMock

from scm.config.security.vulnerability_protection_profile import (
    VulnerabilityProtectionProfile,
)
from scm.exceptions import ValidationError
from scm.models.security.vulnerability_protection_profiles import (
    VulnerabilityProtectionProfileCreateModel,
    VulnerabilityProtectionProfileResponseModel,
    VulnerabilityProtectionProfileUpdateModel,
    RuleRequest,
    ThreatExceptionRequest,
    Severity,
    ActionRequest,
    ActionResponse,
    TimeAttribute,
)


@pytest.mark.usefixtures("load_env")
class TestVulnerabilityProtectionProfileBase:
    """Base class for Vulnerability Protection Profile tests."""

    @pytest.fixture(autouse=True)
    def setup_method(self, mock_scm):
        """Setup method that runs before each test."""
        self.mock_scm = mock_scm  # noqa
        self.mock_scm.get = MagicMock()
        self.mock_scm.post = MagicMock()
        self.mock_scm.put = MagicMock()
        self.mock_scm.delete = MagicMock()
        self.client = VulnerabilityProtectionProfile(self.mock_scm)  # noqa


class TestVulnerabilityProtectionProfileAPI(TestVulnerabilityProtectionProfileBase):
    """Tests for Vulnerability Protection Profile API operations."""

    def test_list_vulnerability_protection_profiles(self):
        """
        Test listing vulnerability protection profiles.

        **Objective:** Test listing all vulnerability protection profiles.
        **Workflow:**
            1. Sets up a mock response resembling the expected API response.
            2. Calls the `list` method with a filter parameter.
            3. Asserts that the mocked service was called correctly.
            4. Validates the returned list of profiles.
        """
        mock_response = {
            "data": [
                {
                    "id": "123e4567-e89b-12d3-a456-426655440000",
                    "name": "TestProfile1",
                    "folder": "Prisma Access",
                    "description": "A test vulnerability protection profile",
                    "rules": [
                        {
                            "name": "TestRule1",
                            "severity": ["critical", "high"],
                            "category": "dos",
                            "host": "client",
                            "threat_name": "any",
                            "packet_capture": "single-packet",
                            "action": {"alert": {}},
                        }
                    ],
                    "threat_exception": [
                        {
                            "name": "TestException1",
                            "action": {"allow": {}},
                            "packet_capture": "single-packet",
                            "exempt_ip": [{"name": "192.168.1.1"}],
                            "notes": "Test note",
                        }
                    ],
                }
            ]
        }

        self.mock_scm.get.return_value = mock_response  # noqa
        profiles = self.client.list(folder="Prisma Access")

        self.mock_scm.get.assert_called_once_with(  # noqa
            "/config/security/v1/vulnerability-protection-profiles",
            params={"folder": "Prisma Access"},
        )
        assert isinstance(profiles, list)
        assert isinstance(profiles[0], VulnerabilityProtectionProfileResponseModel)
        assert profiles[0].name == "TestProfile1"
        assert profiles[0].rules[0].severity == [Severity.critical, Severity.high]

    def test_create_vulnerability_protection_profile(self):
        """
        Test creating a vulnerability protection profile.

        **Objective:** Test creating a new vulnerability protection profile.
        **Workflow:**
            1. Prepares test data for profile creation.
            2. Mocks the API response.
            3. Calls create method and validates the result.
        """
        test_profile_data = {
            "name": "NewTestProfile",
            "folder": "Prisma Access",
            "description": "A new test vulnerability protection profile",
            "rules": [
                {
                    "name": "NewRule",
                    "severity": ["medium", "low"],
                    "category": "code-execution",
                    "packet_capture": "extended-capture",
                    "action": {"block_ip": {"track_by": "source", "duration": 300}},
                    "host": "server",
                }
            ],
            "threat_exception": [
                {
                    "name": "NewException",
                    "action": "allow",
                    "packet_capture": "disable",
                    "exempt_ip": [{"name": "10.0.0.1"}],
                    "notes": "Exception note",
                }
            ],
        }

        mock_response = test_profile_data.copy()
        mock_response["id"] = "333e4567-e89b-12d3-a456-426655440002"

        self.mock_scm.post.return_value = mock_response  # noqa
        created_profile = self.client.create(test_profile_data)

        assert isinstance(created_profile, VulnerabilityProtectionProfileResponseModel)
        assert created_profile.id == "333e4567-e89b-12d3-a456-426655440002"
        assert created_profile.name == "NewTestProfile"

    def test_get_vulnerability_protection_profile(self):
        """
        Test retrieving a vulnerability protection profile by ID.

        **Objective:** Test fetching a specific profile by ID.
        **Workflow:**
            1. Mocks the API response for a specific profile.
            2. Calls get method and validates the result.
        """
        profile_id = "123e4567-e89b-12d3-a456-426655440000"
        mock_response = {
            "id": profile_id,
            "name": "TestProfile",
            "folder": "Prisma Access",
            "description": "A test vulnerability protection profile",
            "rules": [],
            "threat_exception": [],
        }

        self.mock_scm.get.return_value = mock_response  # noqa
        profile = self.client.get(profile_id)

        self.mock_scm.get.assert_called_once_with(  # noqa
            f"/config/security/v1/vulnerability-protection-profiles/{profile_id}"
        )
        assert isinstance(profile, VulnerabilityProtectionProfileResponseModel)
        assert profile.id == profile_id

    def test_update_vulnerability_protection_profile(self):
        """
        Test updating a vulnerability protection profile.

        **Objective:** Test updating an existing profile.
        **Workflow:**
            1. Prepares update data.
            2. Mocks the API response.
            3. Calls update method and validates the result.
        """
        profile_id = "123e4567-e89b-12d3-a456-426655440000"
        update_data = {
            "id": profile_id,
            "name": "UpdatedProfile",
            "folder": "Prisma Access",
            "description": "An updated vulnerability protection profile",
            "rules": [
                {
                    "name": "UpdatedRule",
                    "severity": ["high"],
                    "category": "overflow",
                    "packet_capture": "disable",
                    "action": "drop",
                    "host": "any",
                    "cve": ["CVE-2021-12345"],
                }
            ],
            "threat_exception": [],
        }

        mock_response = update_data.copy()
        self.mock_scm.put.return_value = mock_response  # noqa

        updated_profile = self.client.update(update_data)

        assert isinstance(updated_profile, VulnerabilityProtectionProfileResponseModel)
        assert updated_profile.id == profile_id
        assert updated_profile.name == "UpdatedProfile"

    def test_delete_vulnerability_protection_profile(self):
        """
        Test deleting a vulnerability protection profile.

        **Objective:** Test profile deletion.
        **Workflow:**
            1. Calls delete method with a profile ID.
            2. Verifies the correct endpoint was called.
        """
        profile_id = "123e4567-e89b-12d3-a456-426655440000"
        self.client.delete(profile_id)
        self.mock_scm.delete.assert_called_once_with(  # noqa
            f"/config/security/v1/vulnerability-protection-profiles/{profile_id}"
        )


class TestVulnerabilityProtectionProfileValidation(
    TestVulnerabilityProtectionProfileBase
):
    """Tests for Vulnerability Protection Profile validation."""

    def test_request_model_container_validation(self):
        """Test container validation in request model."""
        # No container provided
        data_no_container = {
            "name": "InvalidProfile",
            "rules": [],
        }
        with pytest.raises(ValueError) as exc_info:
            VulnerabilityProtectionProfileCreateModel(**data_no_container)
        assert (
            "Exactly one of 'folder', 'snippet', or 'device' must be provided."
            in str(exc_info.value)
        )

        # Multiple containers provided
        data_multiple_containers = {
            "name": "InvalidProfile",
            "folder": "Shared",
            "device": "Device1",
            "rules": [],
        }
        with pytest.raises(ValueError) as exc_info:
            VulnerabilityProtectionProfileCreateModel(**data_multiple_containers)
        assert (
            "Exactly one of 'folder', 'snippet', or 'device' must be provided."
            in str(exc_info.value)
        )

    def test_rule_request_validation(self):
        """Test validation in RuleRequest model."""
        # Invalid severity
        data_invalid_severity = {
            "name": "TestRule",
            "severity": ["nonexistent_severity"],
            "category": "code-execution",
            "action": "alert",
        }
        with pytest.raises(ValueError) as exc_info:
            RuleRequest(**data_invalid_severity)
        assert "1 validation error for RuleRequest" in str(exc_info.value)

    def test_threat_exception_validation(self):
        """Test validation in ThreatExceptionRequest model."""
        # Invalid packet_capture
        data_invalid_packet_capture = {
            "name": "TestException",
            "action": "alert",
            "packet_capture": "invalid_option",
        }
        with pytest.raises(ValueError) as exc_info:
            ThreatExceptionRequest(**data_invalid_packet_capture)
        assert "1 validation error for ThreatExceptionRequest" in str(exc_info.value)

    def test_action_validation(self):
        """Test action validation."""
        # Test invalid action type
        with pytest.raises(ValueError) as exc_info:
            ActionRequest(123)  # noqa
        assert "Invalid action format; must be a string or dict." in str(exc_info.value)

        # Test multiple actions
        with pytest.raises(ValueError) as exc_info:
            ActionRequest({"alert": {}, "drop": {}})
        assert "Exactly one action must be provided in 'action' field." in str(
            exc_info.value
        )

    def test_time_attribute_validation(self):
        """Test validation in TimeAttribute model."""
        # Invalid interval
        invalid_data = {
            "interval": 0,
            "threshold": 100,
            "track_by": "source",
        }
        with pytest.raises(ValueError) as exc_info:
            TimeAttribute(**invalid_data)
        assert "Input should be greater than or equal to 1" in str(exc_info.value)

    # Missing Test 1
    def test_action_request_block_ip_non_dict_value(self):
        """
        Test that providing a non-dict value for 'block_ip' action raises ValueError.
        """
        invalid_action = {"block_ip": "invalid_value"}
        with pytest.raises(ValueError) as exc_info:
            ActionRequest(invalid_action)
        assert (
            "'block_ip' action must be a dict with 'track_by' and 'duration' fields."
            in str(exc_info.value)
        )

    # Missing Test 2
    def test_action_request_block_ip_invalid_fields(self):
        """
        Test that invalid 'block_ip' action fields raise ValueError.
        """
        invalid_action = {"block_ip": {"track_by": "invalid", "duration": -1}}
        with pytest.raises(ValueError) as exc_info:
            ActionRequest(invalid_action)
        assert "Invalid 'block_ip' action:" in str(exc_info.value)

    # Missing Test 3
    def test_action_request_non_block_ip_action_with_parameters(self):
        """
        Test that providing parameters for non-block_ip actions raises ValueError.
        """
        invalid_action = {"alert": {"unexpected": "parameter"}}
        with pytest.raises(ValueError) as exc_info:
            ActionRequest(invalid_action)
        assert "Action 'alert' does not take any parameters." in str(exc_info.value)

    # Missing Test 4
    def test_action_request_get_action_name(self):
        """
        Test that get_action_name returns the correct action name.
        """
        # Valid action
        action = ActionRequest({"alert": {}})
        assert action.get_action_name() == "alert"

        # Another valid action
        action = ActionRequest({"block_ip": {"track_by": "source", "duration": 300}})
        assert action.get_action_name() == "block_ip"

    # Missing Test 5
    def test_action_response_invalid_format(self):
        """
        Test that providing invalid action format raises ValueError in ActionResponse.
        """
        invalid_action = 123  # Not a string or dict
        with pytest.raises(ValueError) as exc_info:
            ActionResponse(invalid_action)  # noqa
        assert "Invalid action format; must be a string or dict." in str(exc_info.value)

    # Missing Test 6
    def test_action_response_multiple_actions(self):
        """
        Test that providing multiple actions raises ValueError in ActionResponse.
        """
        invalid_action = {"alert": {}, "drop": {}}
        with pytest.raises(ValueError) as exc_info:
            ActionResponse(invalid_action)
        assert "At most one action must be provided in 'action' field." in str(
            exc_info.value
        )

    # Missing Test 7
    def test_action_response_block_ip_non_dict_value(self):
        """
        Test that providing a non-dict value for 'block_ip' action raises ValueError in ActionResponse.
        """
        invalid_action = {"block_ip": "invalid_value"}
        with pytest.raises(ValueError) as exc_info:
            ActionResponse(invalid_action)
        assert (
            "'block_ip' action must be a dict with 'track_by' and 'duration' fields."
            in str(exc_info.value)
        )

    # Missing Test 8
    def test_action_response_block_ip_invalid_fields(self):
        """
        Test that invalid 'block_ip' action fields raise ValueError in ActionResponse.
        """
        invalid_action = {"block_ip": {"track_by": "invalid", "duration": -1}}
        with pytest.raises(ValueError) as exc_info:
            ActionResponse(invalid_action)
        assert "Invalid 'block_ip' action:" in str(exc_info.value)

    # Missing Test 9
    def test_action_response_non_block_ip_action_with_parameters(self):
        """
        Test that providing parameters for non-block_ip actions raises ValueError in ActionResponse.
        """
        invalid_action = {"alert": {"unexpected": "parameter"}}
        with pytest.raises(ValueError) as exc_info:
            ActionResponse(invalid_action)
        assert "Action 'alert' does not take any parameters." in str(exc_info.value)

    # Missing Test 10
    def test_action_response_invalid_action(self):
        """
        Test that providing an invalid action raises ValueError in ActionResponse.
        """
        invalid_action = {"invalid_action": {}}
        with pytest.raises(ValueError) as exc_info:
            ActionResponse(invalid_action)
        assert "Invalid action format." in str(exc_info.value)

    # Missing Test 11
    def test_action_response_get_action_name(self):
        """
        Test that get_action_name returns the correct action name or 'unknown' in ActionResponse.
        """
        # Valid action
        action = ActionResponse({"drop": {}})
        assert action.get_action_name() == "drop"

        # No action provided
        action = ActionResponse({})
        assert action.get_action_name() == "unknown"

    # Missing Test 12
    def test_vulnerability_protection_profile_response_invalid_id(self):
        """
        Test that invalid UUID in 'id' field raises ValueError in ResponseModel.
        """
        invalid_data = {
            "id": "invalid-uuid",
            "name": "TestProfile",
            "rules": [],
        }
        with pytest.raises(ValueError) as exc_info:
            VulnerabilityProtectionProfileResponseModel(**invalid_data)
        assert "Invalid UUID format for 'id'" in str(exc_info.value)

    # Missing Test 13
    def test_vulnerability_protection_profile_update_invalid_id(self):
        """
        Test that invalid UUID in 'id' field raises ValueError in UpdateModel.
        """
        invalid_data = {
            "id": "invalid-uuid",
            "name": "TestProfile",
            "rules": [],
        }
        with pytest.raises(ValueError) as exc_info:
            VulnerabilityProtectionProfileUpdateModel(**invalid_data)
        assert "Invalid UUID format for 'id'" in str(exc_info.value)

    def test_update_model_uuid_validation(self):
        """Test UUID validation in UpdateModel."""
        # Test valid UUID
        valid_uuid = "123e4567-e89b-12d3-a456-426655440000"
        data = {"id": valid_uuid, "name": "TestProfile", "folder": "Shared"}
        model = VulnerabilityProtectionProfileUpdateModel(**data)
        assert model.id == valid_uuid

        # Test invalid UUID
        invalid_data = {"id": "invalid-uuid", "name": "TestProfile", "folder": "Shared"}
        with pytest.raises(ValueError) as exc_info:
            VulnerabilityProtectionProfileUpdateModel(**invalid_data)
        assert "Invalid UUID format for 'id'" in str(exc_info.value)

    def test_list_pagination_validation(self):
        """Test pagination parameter validation in list method."""
        # Test invalid offset
        with pytest.raises(ValueError) as exc_info:
            self.client.list(folder="Shared", offset=-1)
        assert "Offset must be a non-negative integer" in str(exc_info.value)

        # Test invalid limit
        with pytest.raises(ValueError) as exc_info:
            self.client.list(folder="Shared", limit=0)
        assert "Limit must be a positive integer" in str(exc_info.value)

        # Test both invalid
        with pytest.raises(ValueError) as exc_info:
            self.client.list(folder="Shared", offset=-1, limit=0)
        assert (
            "Offset must be a non-negative integer. Limit must be a positive integer"
            in str(exc_info.value)
        )

    def test_list_container_validation(self):
        """Test container validation in list method."""
        # Test no container
        with pytest.raises(ValidationError) as exc_info:
            self.client.list()
        assert (
            "Exactly one of 'folder', 'snippet', or 'device' must be provided"
            in str(exc_info.value)
        )

        # Test multiple containers
        with pytest.raises(ValidationError) as exc_info:
            self.client.list(folder="Shared", device="Device1")
        assert (
            "Exactly one of 'folder', 'snippet', or 'device' must be provided"
            in str(exc_info.value)
        )

    def test_list_parameter_handling(self):
        """Test parameter handling in list method."""
        mock_response = {"data": []}
        self.mock_scm.get.return_value = mock_response  # noqa

        # Test pagination parameters
        self.client.list(folder="Shared", offset=10, limit=20, name="TestProfile")

        called_params = self.mock_scm.get.call_args[1]["params"]  # noqa
        assert called_params["offset"] == 10
        assert called_params["limit"] == 20
        assert called_params["name"] == "TestProfile"
        assert called_params["folder"] == "Shared"

    def test_fetch_validation_and_handling(self):
        """Test fetch method validation and parameter handling."""
        mock_response = {
            "id": "123e4567-e89b-12d3-a456-426655440000",
            "name": "TestProfile",
            "folder": "Shared",
            # Add required rules field
            "rules": [
                {
                    "name": "TestRule",
                    "action": {"alert": {}},
                    # Add other required fields for rule
                    "severity": ["critical"],
                    "category": "dos",
                }
            ],
            # Optional field
            "threat_exception": [],
        }
        self.mock_scm.get.return_value = mock_response  # noqa

        # Test missing name
        with pytest.raises(ValidationError) as exc_info:
            self.client.fetch("")
        assert "Parameter 'name' must be provided for fetch method" in str(
            exc_info.value
        )

        # Test container validation
        with pytest.raises(ValidationError) as exc_info:
            self.client.fetch("TestProfile", folder="Shared", device="Device1")
        assert (
            "Exactly one of 'folder', 'snippet', or 'device' must be provided"
            in str(exc_info.value)
        )

        # Test successful fetch with additional filters
        result = self.client.fetch(
            "TestProfile", folder="Shared", custom_filter="value"
        )

        called_params = self.mock_scm.get.call_args[1]["params"]  # noqa
        assert isinstance(called_params, dict)
        assert called_params["name"] == "TestProfile"
        assert called_params["folder"] == "Shared"
        assert called_params["custom_filter"] == "value"
        assert isinstance(result, dict)
        # Add assertion to verify rules are present in result
        assert "rules" in result


class TestSuite(
    TestVulnerabilityProtectionProfileAPI,
    TestVulnerabilityProtectionProfileValidation,
):
    """Main test suite that combines all test classes."""

    pass
