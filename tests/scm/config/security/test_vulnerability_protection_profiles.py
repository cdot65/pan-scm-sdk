# tests/scm/config/security/test_vulnerability_protection_profile.py

from unittest.mock import MagicMock

import pytest
from pydantic import ValidationError as PydanticValidationError

from scm.config.security.vulnerability_protection_profile import (
    VulnerabilityProtectionProfile,
)
from scm.exceptions import (
    APIError,
    InvalidObjectError,
    ObjectNotPresentError,
    MalformedCommandError,
    MissingQueryParameterError,
    ReferenceNotZeroError,
)
from scm.models.security.vulnerability_protection_profiles import (
    VulnerabilityProfileCreateModel,
    VulnerabilityProfileResponseModel,
    VulnerabilityProfileRuleModel,
    VulnerabilityProfileThreatExceptionModel,
    VulnerabilityProfileSeverity,
    VulnerabilityProfileActionRequest,
    VulnerabilityProfileActionResponse,
)
from tests.factories import (
    VulnerabilityProtectionProfileRequestFactory,
)


@pytest.mark.usefixtures("load_env")
class TestVulnerabilityProtectionProfileBase:
    """Base class for Vulnerability Protection Profile tests."""

    @pytest.fixture(autouse=True)
    def setup_method(self, mock_scm):
        """Setup method that runs before each test."""
        self.mock_scm = mock_scm  # noqa
        self.mock_scm.get = MagicMock()
        self.mock_scm.post = MagicMock()
        self.mock_scm.put = MagicMock()
        self.mock_scm.delete = MagicMock()
        self.client = VulnerabilityProtectionProfile(self.mock_scm)  # noqa


# -------------------- Test Classes Grouped by Functionality --------------------


class TestVulnerabilityProtectionProfileModelValidation(
    TestVulnerabilityProtectionProfileBase
):
    """Tests for object model validation."""

    def test_object_model_no_container_provided(self):
        """Test validation when no container is provided."""
        data = {
            "name": "InvalidProfile",
            "rules": [],
        }
        with pytest.raises(PydanticValidationError) as exc_info:
            VulnerabilityProfileCreateModel(**data)
        assert (
            "Exactly one of 'folder', 'snippet', or 'device' must be provided."
            in str(exc_info.value)
        )

    def test_object_model_multiple_containers(self):
        """Test validation when multiple containers are provided."""
        data = {
            "name": "InvalidProfile",
            "folder": "Shared",
            "device": "Device1",
            "rules": [],
        }
        with pytest.raises(PydanticValidationError) as exc_info:
            VulnerabilityProfileCreateModel(**data)
        assert (
            "Exactly one of 'folder', 'snippet', or 'device' must be provided."
            in str(exc_info.value)
        )

    def test_rule_request_validation(self):
        """Test validation in VulnerabilityRuleModel model."""
        # Invalid severity
        data_invalid_severity = {
            "name": "TestRule",
            "severity": ["nonexistent_severity"],
            "category": "code-execution",
            "host": "client",  # Added required field
            "threat_name": "any",  # Added required field
            "action": {"alert": {}},  # Updated action format
        }
        with pytest.raises(PydanticValidationError) as exc_info:
            VulnerabilityProfileRuleModel(**data_invalid_severity)
        assert "Input should be 'critical', 'high', 'medium'" in str(exc_info.value)

    def test_threat_exception_validation(self):
        """Test validation in ThreatExceptionModel model."""
        # Invalid packet_capture
        data_invalid_packet_capture = {
            "name": "TestException",
            "action": "alert",
            "packet_capture": "invalid_option",
        }
        with pytest.raises(PydanticValidationError) as exc_info:
            VulnerabilityProfileThreatExceptionModel(**data_invalid_packet_capture)
        assert "1 validation error for ThreatExceptionModel" in str(exc_info.value)


class TestVulnerabilityProtectionProfileList(TestVulnerabilityProtectionProfileBase):
    """Tests for listing Vulnerability Protection Profile objects."""

    def test_list_objects(self):
        """
        **Objective:** Test listing all objects.
        **Workflow:**
            1. Sets up a mock response resembling the expected API response for listing objects.
            2. Calls the `list` method with a filter parameter.
            3. Asserts that the mocked service was called correctly.
            4. Validates the returned list of objects.
        """
        mock_response = {
            "data": [
                {
                    "id": "123e4567-e89b-12d3-a456-426655440000",
                    "name": "TestProfile1",
                    "folder": "Prisma Access",
                    "description": "A test vulnerability protection profile",
                    "rules": [
                        {
                            "name": "TestRule1",
                            "severity": ["critical", "high"],
                            "category": "dos",
                            "host": "client",
                            "threat_name": "any",
                            "packet_capture": "single-packet",
                            "action": {"alert": {}},
                        }
                    ],
                    "threat_exception": [
                        {
                            "name": "TestException1",
                            "action": {"allow": {}},
                            "packet_capture": "single-packet",
                            "exempt_ip": [{"name": "192.168.1.1"}],
                            "notes": "Test note",
                        }
                    ],
                }
            ]
        }

        self.mock_scm.get.return_value = mock_response  # noqa
        existing_objects = self.client.list(folder="Prisma Access")

        self.mock_scm.get.assert_called_once_with(  # noqa
            "/config/security/v1/vulnerability-protection-profiles",
            params={
                "limit": 10000,
                "folder": "Prisma Access",
            },
        )
        assert isinstance(existing_objects, list)
        assert isinstance(existing_objects[0], VulnerabilityProfileResponseModel)
        assert existing_objects[0].name == "TestProfile1"
        assert existing_objects[0].rules[0].severity == [
            VulnerabilityProfileSeverity.critical,
            VulnerabilityProfileSeverity.high,
        ]

    def test_object_list_multiple_containers(self):
        """Test validation error when listing with multiple containers."""
        with pytest.raises(InvalidObjectError) as exc_info:
            self.client.list(folder="Prisma Access", snippet="TestSnippet")

        assert (
            "Exactly one of 'folder', 'snippet', or 'device' must be provided."
            in str(exc_info.value)
        )

    def test_invalid_response_format(self):
        """Test handling of non-dict response."""
        # Test with list response
        self.mock_scm.get.return_value = ["not", "a", "dict"]
        with pytest.raises(APIError) as exc_info:
            self.client.list(folder="Shared")
        assert "Invalid response format: expected dictionary" in str(exc_info.value)

        # Test with string response
        self.mock_scm.get.return_value = "string response"
        with pytest.raises(APIError) as exc_info:
            self.client.list(folder="Shared")
        assert "Invalid response format: expected dictionary" in str(exc_info.value)

        # Test with None response
        self.mock_scm.get.return_value = None
        with pytest.raises(APIError) as exc_info:
            self.client.list(folder="Shared")
        assert "Invalid response format: expected dictionary" in str(exc_info.value)


class TestVulnerabilityProtectionProfileCreate(TestVulnerabilityProtectionProfileBase):
    """Tests for creating Vulnerability Protection Profile objects."""

    def test_create_object(self):
        """
        **Objective:** Test creating a new object.
        **Workflow:**
            1. Creates test data using VulnerabilityProtectionProfileRequestFactory.
            2. Mocks the API response.
            3. Verifies the creation request and response.
        """
        test_object = VulnerabilityProtectionProfileRequestFactory()
        mock_response = test_object.model_dump()
        mock_response["id"] = "12345678-abcd-abcd-abcd-123456789012"

        self.mock_scm.post.return_value = mock_response  # noqa
        created_object = self.client.create(test_object.model_dump(exclude_unset=True))

        self.mock_scm.post.assert_called_once_with(  # noqa
            "/config/security/v1/vulnerability-protection-profiles",
            json=test_object.model_dump(exclude_unset=True),
        )
        assert str(created_object.id) == "12345678-abcd-abcd-abcd-123456789012"
        assert created_object.name == test_object.name
        assert created_object.description == test_object.description

    def test_create_object_error_handling(self):
        """
        **Objective:** Test error handling during object creation.
        **Workflow:**
            1. Mocks an error response from the API
            2. Attempts to create an object
            3. Verifies proper error handling and exception raising
        """
        test_data = VulnerabilityProtectionProfileRequestFactory()

        # Mock error response
        mock_error_response = {
            "_errors": [
                {
                    "code": "API_I00013",
                    "message": "Object creation failed",
                    "details": {"errorType": "Object Already Exists"},
                }
            ],
            "_request_id": "test-request-id",
        }

        # Configure mock to raise exception
        self.mock_scm.post.side_effect = Exception()  # noqa
        self.mock_scm.post.side_effect.response = MagicMock()  # noqa
        self.mock_scm.post.side_effect.response.json = MagicMock(  # noqa
            return_value=mock_error_response
        )

        with pytest.raises(APIError):
            self.client.create(test_data.model_dump())

    def test_create_generic_exception_handling(self):
        """
        **Objective:** Test generic exception handling in create method.
        **Workflow:**
            1. Mocks a generic exception without response attribute
            2. Verifies APIError is raised with correct message
        """
        test_data = VulnerabilityProtectionProfileRequestFactory()

        # Mock a generic exception without response
        self.mock_scm.post.side_effect = Exception("Generic error")  # noqa

        with pytest.raises(APIError) as exc_info:
            self.client.create(test_data.model_dump())
        assert str(exc_info.value) == "An unexpected error occurred"

    def test_create_malformed_response_handling(self):
        """
        **Objective:** Test handling of malformed response in create method.
        **Workflow:**
            1. Mocks a response that would cause a parsing error
            2. Verifies appropriate error handling
        """
        test_data = VulnerabilityProtectionProfileRequestFactory()

        # Mock invalid JSON response
        self.mock_scm.post.return_value = {"malformed": "response"}  # noqa

        with pytest.raises(APIError):
            self.client.create(test_data.model_dump())


class TestVulnerabilityProtectionProfileGet(TestVulnerabilityProtectionProfileBase):
    """Tests for retrieving a specific Vulnerability Protection Profile object."""

    def test_get_object(self):
        """
        **Objective:** Test retrieving a specific object.
        **Workflow:**
            1. Mocks the API response for a specific object.
            2. Verifies the get request and response handling.
        """
        profile_id = "123e4567-e89b-12d3-a456-426655440000"
        mock_response = {
            "id": profile_id,
            "name": "TestProfile",
            "folder": "Prisma Access",
            "description": "A test vulnerability protection profile",
            "rules": [],
            "threat_exception": [],
        }

        self.mock_scm.get.return_value = mock_response  # noqa
        get_object = self.client.get(profile_id)

        self.mock_scm.get.assert_called_once_with(  # noqa
            f"/config/security/v1/vulnerability-protection-profiles/{profile_id}"
        )
        assert isinstance(get_object, VulnerabilityProfileResponseModel)
        assert str(get_object.id) == profile_id

    def test_get_object_error_handling(self):
        """
        **Objective:** Test error handling during object retrieval.
        **Workflow:**
            1. Mocks an error response from the API
            2. Attempts to get an object
            3. Verifies proper error handling and exception raising
        """
        object_id = "123e4567-e89b-12d3-a456-426655440000"

        mock_error_response = {
            "_errors": [
                {
                    "code": "API_I00013",
                    "message": "Object not found",
                    "details": {"errorType": "Object Not Present"},
                }
            ],
            "_request_id": "test-request-id",
        }

        self.mock_scm.get.side_effect = Exception()  # noqa
        self.mock_scm.get.side_effect.response = MagicMock()  # noqa
        self.mock_scm.get.side_effect.response.json = MagicMock(  # noqa
            return_value=mock_error_response
        )

        with pytest.raises(ObjectNotPresentError):
            self.client.get(object_id)

    def test_get_generic_exception_handling(self):
        """
        **Objective:** Test generic exception handling in get method.
        **Workflow:**
            1. Mocks a generic exception without response attribute
            2. Verifies APIError is raised with correct message
        """
        object_id = "123e4567-e89b-12d3-a456-426655440000"

        # Mock a generic exception without response
        self.mock_scm.get.side_effect = Exception("Generic error")  # noqa

        with pytest.raises(APIError) as exc_info:
            self.client.get(object_id)
        assert str(exc_info.value) == "An unexpected error occurred: Generic error"


class TestVulnerabilityProtectionProfileUpdate(TestVulnerabilityProtectionProfileBase):
    """Tests for updating Vulnerability Protection Profile objects."""

    def test_update_object(self):
        """
        **Objective:** Test updating an object.
        **Workflow:**
            1. Prepares update data and mocks response
            2. Verifies the update request and response
            3. Ensures payload transformation is correct
        """
        from uuid import UUID

        test_uuid = UUID("123e4567-e89b-12d3-a456-426655440000")

        # Test data including ID
        update_data = {
            "id": str(test_uuid),
            "name": "UpdatedProfile",
            "folder": "Prisma Access",
            "description": "An updated vulnerability protection profile",
            "rules": [
                {
                    "name": "UpdatedRule",
                    "severity": ["high"],
                    "category": "overflow",
                    "packet_capture": "disable",
                    "action": {"alert": {}},  # Updated action format
                    "host": "any",
                    "threat_name": "any",
                }
            ],
            "threat_exception": [],
        }

        # Mock response should include the ID
        mock_response = update_data.copy()
        self.mock_scm.put.return_value = mock_response  # noqa

        # Perform update
        updated_object = self.client.update(update_data)

        # Verify correct endpoint and payload
        self.mock_scm.put.assert_called_once_with(  # noqa
            f"/config/security/v1/vulnerability-protection-profiles/{update_data['id']}",
            json={k: v for k, v in update_data.items() if k != "id"},
        )

        assert isinstance(updated_object, VulnerabilityProfileResponseModel)
        assert isinstance(updated_object.id, UUID)
        assert updated_object.id == test_uuid
        assert str(updated_object.id) == update_data["id"]
        assert updated_object.name == "UpdatedProfile"

    def test_update_object_error_handling(self):
        """
        **Objective:** Test error handling during object update.
        **Workflow:**
            1. Mocks an error response from the API
            2. Attempts to update an object
            3. Verifies proper error handling and exception raising
        """
        update_data = {
            "id": "123e4567-e89b-12d3-a456-426655440000",
            "name": "test-profile",
            "folder": "Shared",
            "rules": [
                {
                    "name": "TestRule",
                    "severity": ["high"],
                    "category": "overflow",
                    "host": "any",
                    "cve": ["any"],
                    "vendor-id": ["any"],
                    "threat_name": "any",
                    "packet_capture": "disable",
                }
            ],
        }

        mock_error_response = {
            "_errors": [
                {
                    "code": "API_I00013",
                    "message": "Update failed",
                    "details": {"errorType": "Malformed Command"},
                }
            ],
            "_request_id": "test-request-id",
        }

        self.mock_scm.put.side_effect = Exception()  # noqa
        self.mock_scm.put.side_effect.response = MagicMock()  # noqa
        self.mock_scm.put.side_effect.response.json = MagicMock(  # noqa
            return_value=mock_error_response
        )

        with pytest.raises(MalformedCommandError):
            self.client.update(update_data)

    def test_update_with_invalid_data(self):
        """
        **Objective:** Test update method with invalid data structure.
        **Workflow:**
            1. Attempts to update with invalid data
            2. Verifies proper validation error handling
        """
        invalid_data = {
            "id": "123e4567-e89b-12d3-a456-426655440000",
            "invalid_field": "test",
        }

        with pytest.raises(APIError):
            self.client.update(invalid_data)

    def test_update_generic_exception_handling(self):
        """
        **Objective:** Test generic exception handling in update method.
        **Workflow:**
            1. Mocks a generic exception without response attribute
            2. Verifies APIError is raised with correct message
        """
        update_data = {
            "id": "123e4567-e89b-12d3-a456-426655440000",
            "name": "test-profile",
            "folder": "Shared",
            "rules": [
                {
                    "name": "TestRule",
                    "severity": ["high"],
                    "category": "overflow",
                    "host": "any",
                    "cve": ["any"],
                    "vendor-id": ["any"],
                    "threat_name": "any",
                    "packet_capture": "disable",
                }
            ],
        }

        # Mock a generic exception without response
        self.mock_scm.put.side_effect = Exception("Generic error")  # noqa

        with pytest.raises(APIError) as exc_info:
            self.client.update(update_data)
        assert str(exc_info.value) == "An unexpected error occurred: Generic error"


class TestVulnerabilityProtectionProfileDelete(TestVulnerabilityProtectionProfileBase):
    """Tests for deleting Vulnerability Protection Profile objects."""

    def test_delete_referenced_object(self):
        """
        **Objective:** Test deleting an object that is referenced by other objects.
        **Workflow:**
            1. Sets up a mock error response for a referenced object deletion attempt
            2. Attempts to delete an object that is referenced by other objects
            3. Validates that ReferenceNotZeroError is raised with correct details
            4. Verifies the error contains proper reference information
        """
        object_id = "3fecfe58-af0c-472b-85cf-437bb6df2929"

        # Mock the API error response
        mock_error_response = {
            "_errors": [
                {
                    "code": "E009",  # Changed from API_I00013 to E009
                    "message": "Your configuration is not valid. Please review the error message for more details.",
                    "details": {
                        "errorType": "Reference Not Zero",
                        "message": [
                            " container -> Texas -> security-profile-group -> custom-group -> vulnerability-protection"
                        ],
                        "errors": [
                            {
                                "type": "NON_ZERO_REFS",
                                "message": "Node cannot be deleted because of references from",
                                "params": ["custom-profile"],
                                "extra": [
                                    "container/[Texas]/security-profile-group/[custom-group]/vulnerability-protection/[custom-profile]"
                                ],
                            }
                        ],
                    },
                }
            ],
            "_request_id": "8fe3b025-feb7-41d9-bf88-3938c0b33116",
        }

        # Configure mock with status code
        mock_exc = Exception()
        mock_exc.response = MagicMock()
        mock_exc.response.status_code = 409  # Add status code
        mock_exc.response.json.return_value = mock_error_response
        self.mock_scm.delete.side_effect = mock_exc

        with pytest.raises(ReferenceNotZeroError) as exc_info:
            self.client.delete(object_id)

        error = exc_info.value

        # Verify the error contains the expected information
        assert error.error_code == "E009"
        assert "HTTP 409: Error E009: Your configuration is not valid." in str(error)

        # Verify the delete method was called with correct endpoint
        self.mock_scm.delete.assert_called_once_with(  # noqa
            f"/config/security/v1/vulnerability-protection-profiles/{object_id}"
        )

    def test_delete_error_handling(self):
        """
        **Objective:** Test error handling during object deletion.
        **Workflow:**
            1. Mocks various error scenarios
            2. Verifies proper error handling for each case
        """
        object_id = "123e4567-e89b-12d3-a456-426655440000"

        # Test object not found
        mock_error_response = {
            "_errors": [
                {
                    "code": "API_I00013",
                    "message": "Object not found",
                    "details": {"errorType": "Object Not Present"},
                }
            ],
            "_request_id": "test-request-id",
        }

        self.mock_scm.delete.side_effect = Exception()  # noqa
        self.mock_scm.delete.side_effect.response = MagicMock()  # noqa
        self.mock_scm.delete.side_effect.response.json = MagicMock(  # noqa
            return_value=mock_error_response
        )

        with pytest.raises(ObjectNotPresentError):
            self.client.delete(object_id)

    def test_delete_generic_exception_handling(self):
        """
        **Objective:** Test generic exception handling in delete method.
        **Workflow:**
            1. Mocks a generic exception without response attribute
            2. Verifies APIError is raised with correct message
        """
        object_id = "123e4567-e89b-12d3-a456-426655440000"

        # Mock a generic exception without response
        self.mock_scm.delete.side_effect = Exception("Generic error")  # noqa

        with pytest.raises(APIError) as exc_info:
            self.client.delete(object_id)
        assert str(exc_info.value) == "An unexpected error occurred: Generic error"


class TestVulnerabilityProtectionProfileFetch(TestVulnerabilityProtectionProfileBase):
    """Tests for fetching Vulnerability Protection Profile objects by name."""

    def test_fetch_object(self):
        """
        **Objective:** Test retrieving an object by its name using the `fetch` method.
        **Workflow:**
            1. Sets up a mock response resembling the expected API response for fetching an object by name.
            2. Calls the `fetch` method of `self.client` with a specific name and container.
            3. Asserts that the mocked service was called with the correct URL and parameters.
            4. Validates the returned object's attributes.
        """
        mock_response = {
            "id": "123e4567-e89b-12d3-a456-426655440000",
            "name": "test-profile",
            "folder": "Shared",
            "description": "Test vulnerability protection profile",
            "rules": [
                {
                    "name": "TestRule",
                    "severity": ["critical"],
                    "category": "dos",
                    "host": "any",
                    "threat_name": "any",
                    "action": {"alert": {}},
                    "packet_capture": "single-packet",
                }
            ],
            "threat_exception": [],
        }

        self.mock_scm.get.return_value = mock_response  # noqa

        # Call the fetch method
        fetched_object = self.client.fetch(
            name=mock_response["name"],
            folder=mock_response["folder"],
        )

        # Assert that the GET request was made with the correct parameters
        self.mock_scm.get.assert_called_once_with(  # noqa
            "/config/security/v1/vulnerability-protection-profiles",
            params={
                "folder": mock_response["folder"],
                "name": mock_response["name"],
            },
        )

        # Validate the returned object
        assert isinstance(fetched_object, dict)
        assert str(fetched_object["id"]) == mock_response["id"]
        assert fetched_object["name"] == mock_response["name"]
        assert fetched_object["description"] == mock_response["description"]
        assert fetched_object["rules"][0]["severity"] == ["critical"]

    def test_fetch_object_not_found(self):
        """
        Test fetching an object by name that does not exist.
        """
        object_name = "NonExistent"
        folder_name = "Shared"
        mock_response = {
            "_errors": [
                {
                    "code": "E005",  # Changed from API_I00013 to E005
                    "message": "Object not found",
                    "details": {"errorType": "Object Not Present"},
                }
            ],
            "_request_id": "12282b0f-eace-41c3-a8e2-4b28992979c4",
        }

        # Configure mock with status code
        mock_exc = Exception()
        mock_exc.response = MagicMock()
        mock_exc.response.status_code = 404  # Add status code
        mock_exc.response.json.return_value = mock_response
        self.mock_scm.get.side_effect = mock_exc

        with pytest.raises(ObjectNotPresentError):
            self.client.fetch(name=object_name, folder=folder_name)

    def test_fetch_empty_name(self):
        """
        **Objective:** Test fetch with empty name parameter.
        **Workflow:**
            1. Attempts to fetch with empty name
            2. Verifies MissingQueryParameterError is raised
        """
        with pytest.raises(MissingQueryParameterError) as exc_info:
            self.client.fetch(name="", folder="Shared")
        assert "Field 'name' cannot be empty" in str(exc_info.value)

    def test_fetch_container_validation(self):
        """
        **Objective:** Test container parameter validation in fetch.
        **Workflow:**
            1. Tests various invalid container combinations
            2. Verifies proper error handling
        """
        # Test empty folder
        with pytest.raises(MissingQueryParameterError) as exc_info:
            self.client.fetch(name="test", folder="")
        assert "Field 'folder' cannot be empty" in str(exc_info.value)

        # Test no container provided
        with pytest.raises(InvalidObjectError) as exc_info:
            self.client.fetch(name="test-profile")
        assert (
            "Exactly one of 'folder', 'snippet', or 'device' must be provided."
            in str(exc_info.value)
        )

        # Test multiple containers provided
        with pytest.raises(InvalidObjectError) as exc_info:
            self.client.fetch(
                name="test-profile", folder="Shared", snippet="TestSnippet"
            )
        assert (
            "Exactly one of 'folder', 'snippet', or 'device' must be provided."
            in str(exc_info.value)
        )

    def test_fetch_object_unexpected_response_format(self):
        """
        Test fetching an object when the API returns an unexpected format.

        **Objective:** Ensure that the fetch method raises APIError when the response format is not as expected.
        **Workflow:**
            1. Mocks the API response to return an unexpected format.
            2. Calls the `fetch` method.
            3. Asserts that APIError is raised.
        """
        group_name = "TestGroup"
        folder_name = "Shared"
        # Mocking an unexpected response format
        mock_response = {"unexpected_key": "unexpected_value"}
        self.mock_scm.get.return_value = mock_response  # noqa

        with pytest.raises(APIError) as exc_info:
            self.client.fetch(name=group_name, folder=folder_name)
        assert "Invalid response format: missing 'id' field" in str(exc_info.value)

    def test_fetch_validation_errors(self):
        """
        **Objective:** Test fetch validation errors.
        **Workflow:**
            1. Tests various invalid input scenarios
            2. Verifies appropriate error handling
        """
        # Test empty folder
        with pytest.raises(MissingQueryParameterError) as exc_info:
            self.client.fetch(name="test", folder="")
        assert "Field 'folder' cannot be empty" in str(exc_info.value)

        # Test multiple containers
        with pytest.raises(InvalidObjectError) as exc_info:
            self.client.fetch(name="test", folder="folder1", snippet="snippet1")
        assert (
            "Exactly one of 'folder', 'snippet', or 'device' must be provided."
            in str(exc_info.value)
        )

    def test_fetch_generic_exception_handling(self):
        """
        **Objective:** Test generic exception handling in fetch method.
        **Workflow:**
            1. Mocks a generic exception without response attribute
            2. Verifies APIError is raised with correct message
        """
        # Mock a generic exception without response
        self.mock_scm.get.side_effect = Exception("Generic error")  # noqa

        with pytest.raises(APIError) as exc_info:
            self.client.fetch(name="test", folder="Shared")
        assert str(exc_info.value) == "An unexpected error occurred: Generic error"

    def test_fetch_response_format_handling(self):
        """
        **Objective:** Test handling of various response formats in fetch method.
        **Workflow:**
            1. Tests different malformed response scenarios
            2. Verifies appropriate error handling for each case
        """
        # Test malformed response without expected fields
        self.mock_scm.get.return_value = {"unexpected": "format"}  # noqa

        with pytest.raises(APIError) as exc_info:
            self.client.fetch(name="test", folder="Shared")
        assert "Invalid response format: missing 'id' field" in str(exc_info.value)

        # Test response with both id and data fields (invalid format)
        self.mock_scm.get.return_value = {  # noqa
            "id": "some-id",
            "data": [{"some": "data"}],
        }  # noqa

        with pytest.raises(APIError) as exc_info:
            self.client.fetch(name="test", folder="Shared")
        assert "An unexpected error occurred: 3 validation errors" in str(
            exc_info.value
        )

        # Test malformed response in list format
        self.mock_scm.get.return_value = [{"unexpected": "format"}]  # noqa
        with pytest.raises(APIError) as exc_info:
            self.client.fetch(name="test", folder="Shared")
        assert "Invalid response format: expected dictionary" in str(exc_info.value)

    def test_fetch_error_handler_json_error(self):
        """
        **Objective:** Test fetch method error handling when json() raises an error.
        **Workflow:**
            1. Mocks an exception with a response that raises error on json()
            2. Verifies the original exception is re-raised
        """
        # Create mock exception
        mock_exc = Exception("Original error")
        mock_exc.response = MagicMock()
        mock_exc.response.status_code = 500
        mock_exc.response.json.side_effect = ValueError("JSON parsing error")

        # Configure mock
        self.mock_scm.get.side_effect = mock_exc

        with pytest.raises(ValueError) as exc_info:
            self.client.fetch(name="test", folder="Shared")
        assert str(exc_info.value) == "JSON parsing error"


class TestActionRequest:
    """Tests for ActionRequest validation."""

    def test_string_input_conversion(self):
        """Test conversion of string input to dict."""
        action = VulnerabilityProfileActionRequest("allow")
        assert action.root == {"allow": {}}

    def test_dict_input_validation(self):
        """Test validation of dict input."""
        action = VulnerabilityProfileActionRequest({"allow": {}})
        assert action.root == {"allow": {}}

    def test_invalid_input_type(self):
        """Test handling of invalid input types."""
        with pytest.raises(ValueError) as exc_info:
            VulnerabilityProfileActionRequest([])
        assert "Value error, Invalid action format; must be a string or dict" in str(
            exc_info.value
        )

    def test_multiple_actions_validation(self):
        """Test validation of multiple actions."""
        with pytest.raises(ValueError) as exc_info:
            VulnerabilityProfileActionRequest({"allow": {}, "alert": {}})
        assert (
            "Value error, Exactly one action must be provided in 'action' field."
            in str(exc_info.value)
        )

    def test_block_ip_validation(self):
        """Test validation of block_ip action."""
        # Valid block_ip action
        valid_block_ip = {"block_ip": {"track_by": "source", "duration": 3600}}
        action = VulnerabilityProfileActionRequest(valid_block_ip)
        assert action.root == valid_block_ip

        # Invalid block_ip action - not a dict
        with pytest.raises(ValueError) as exc_info:
            VulnerabilityProfileActionRequest({"block_ip": "invalid"})
        assert (
            "Value error, 'block_ip' action must be a dict with 'track_by' and 'duration' fields."
            in str(exc_info.value)
        )

        # Invalid block_ip action - missing fields
        with pytest.raises(ValueError) as exc_info:
            VulnerabilityProfileActionRequest({"block_ip": {}})
        assert "Invalid 'block_ip' action:" in str(exc_info.value)

    def test_action_with_parameters(self):
        """Test validation of actions with parameters."""
        with pytest.raises(ValueError) as exc_info:
            VulnerabilityProfileActionRequest({"allow": {"some": "param"}})
        assert "Value error, Action 'allow' does not take any parameters." in str(
            exc_info.value
        )

    def test_get_action_name_all_cases(self):
        """Test all cases for get_action_name method."""
        # Test normal case (dict with keys)
        action = VulnerabilityProfileActionRequest({"allow": {}})
        assert action.get_action_name() == "allow"

        # Test None root - we need to create a valid action first, then set root to None
        action = VulnerabilityProfileActionRequest(
            {"allow": {}}
        )  # Create with valid data first
        action.root = None  # Then modify the root directly
        assert action.get_action_name() == "unknown"

        # Test empty dict case - we need to create a valid action first
        action = VulnerabilityProfileActionRequest(
            {"allow": {}}
        )  # Create with valid data first
        action.root = {}  # Then modify the root directly
        assert action.get_action_name() == "unknown"

        # Test with string (converted to dict)
        action = VulnerabilityProfileActionRequest("alert")
        assert action.get_action_name() == "alert"

        # Test default return when next(iter()) would fail
        # This simulates the case where keys() returns an empty iterator
        class CustomDict(dict):
            def keys(self):
                return iter(())  # Empty iterator

        action = VulnerabilityProfileActionRequest(
            {"allow": {}}
        )  # Create with valid data first
        action.root = CustomDict()  # Then modify the root directly
        assert action.get_action_name() == "unknown"


class TestActionResponse:
    """Tests for ActionResponse validation."""

    def test_string_input_conversion(self):
        """Test conversion of string input to dict."""
        action = VulnerabilityProfileActionResponse("allow")
        assert action.root == {"allow": {}}

    def test_dict_input_validation(self):
        """Test validation of dict input."""
        action = VulnerabilityProfileActionResponse({"allow": {}})
        assert action.root == {"allow": {}}

    def test_invalid_input_type(self):
        """Test handling of invalid input types."""
        with pytest.raises(ValueError) as exc_info:
            VulnerabilityProfileActionResponse([])
        assert "Value error, Invalid action format; must be a string or dict." in str(
            exc_info.value
        )

    def test_multiple_actions_validation(self):
        """Test validation of multiple actions."""
        with pytest.raises(ValueError) as exc_info:
            VulnerabilityProfileActionResponse({"allow": {}, "alert": {}})
        assert (
            "Value error, At most one action must be provided in 'action' field."
            in str(exc_info.value)
        )

    def test_block_ip_validation(self):
        """Test validation of block_ip action."""
        # Valid block_ip action
        valid_block_ip = {"block_ip": {"track_by": "source", "duration": 3600}}
        action = VulnerabilityProfileActionResponse(valid_block_ip)
        assert action.root == valid_block_ip

        # Invalid block_ip action - not a dict
        with pytest.raises(ValueError) as exc_info:
            VulnerabilityProfileActionResponse({"block_ip": "invalid"})
        assert (
            "Value error, 'block_ip' action must be a dict with 'track_by' and 'duration' fields."
            in str(exc_info.value)
        )

        # Invalid block_ip action - missing fields
        with pytest.raises(ValueError) as exc_info:
            VulnerabilityProfileActionResponse({"block_ip": {}})
        assert "Invalid 'block_ip' action:" in str(exc_info.value)

    def test_action_with_parameters(self):
        """Test validation of actions with parameters."""
        with pytest.raises(ValueError) as exc_info:
            VulnerabilityProfileActionResponse({"allow": {"some": "param"}})
        assert "Value error, Action 'allow' does not take any parameters." in str(
            exc_info.value
        )

    def test_empty_action(self):
        """Test handling of empty action."""
        action = VulnerabilityProfileActionResponse({})
        assert action.root == {}

        # Non-empty dict without valid action
        with pytest.raises(ValueError) as exc_info:
            VulnerabilityProfileActionResponse({"invalid": "value"})
        assert "Value error, Invalid action format." in str(exc_info.value)

    def test_get_action_name(self):
        """Test get_action_name method."""
        action = VulnerabilityProfileActionResponse({"allow": {}})
        assert action.get_action_name() == "allow"

        action = VulnerabilityProfileActionResponse({})
        assert action.get_action_name() == "unknown"


# -------------------- End of Test Classes --------------------
