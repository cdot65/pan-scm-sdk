# tests/test_vulnerability_protection_profiles.py

import pytest
from unittest.mock import MagicMock

from scm.config.security.vulnerability_protection_profile import (
    VulnerabilityProtectionProfile,
)
from scm.exceptions import ValidationError
from scm.models.security.vulnerability_protection_profiles import (
    VulnerabilityProtectionProfileRequestModel,
    VulnerabilityProtectionProfileResponseModel,
    RuleRequest,
    RuleResponse,
    ThreatExceptionRequest,
    ThreatExceptionResponse,
    Severity,
    Category,
    PacketCapture,
    ActionRequest,
    ActionResponse,
    Host,
    BlockIpAction,
    BlockIpTrackBy,
    TimeAttribute,
    TimeAttributeTrackBy,
)
from typing import List
import uuid


def test_list_vulnerability_protection_profiles(load_env, mock_scm):
    """
    Test listing vulnerability protection profiles.
    """
    # Mock response from the API client
    mock_response = {
        "data": [
            {
                "id": "123e4567-e89b-12d3-a456-426655440000",
                "name": "TestProfile1",
                "folder": "Prisma Access",
                "description": "A test vulnerability protection profile",
                "rules": [
                    {
                        "name": "TestRule1",
                        "severity": ["critical", "high"],
                        "category": "dos",
                        "host": "client",
                        "threat_name": "any",
                        "packet_capture": "single-packet",
                        "action": {"alert": {}},
                    }
                ],
                "threat_exception": [
                    {
                        "name": "TestException1",
                        "action": {"allow": {}},
                        "packet_capture": "single-packet",
                        "exempt_ip": [{"name": "192.168.1.1"}],
                        "notes": "Test note",
                    }
                ],
            },
            {
                "id": "223e4567-e89b-12d3-a456-426655440001",
                "name": "TestProfile2",
                "folder": "Prisma Access",
                "rules": [],
                "threat_exception": [],
            },
        ],
        "offset": 0,
        "total": 2,
        "limit": 200,
    }

    # Mock the API client's get method
    mock_scm.get = MagicMock(return_value=mock_response)

    # Create an instance of VulnerabilityProtectionProfile with the mocked Scm
    vuln_prot_profile_client = VulnerabilityProtectionProfile(mock_scm)

    # Call the list method
    profiles = vuln_prot_profile_client.list(folder="Prisma Access")

    # Assertions
    mock_scm.get.assert_called_once_with(
        "/config/security/v1/vulnerability-protection-profiles",
        params={"folder": "Prisma Access"},
    )
    assert isinstance(profiles, list)
    assert len(profiles) == 2
    assert isinstance(profiles[0], VulnerabilityProtectionProfileResponseModel)
    assert profiles[0].name == "TestProfile1"
    assert profiles[0].description == "A test vulnerability protection profile"
    assert profiles[0].rules[0].name == "TestRule1"
    assert profiles[0].rules[0].severity == [Severity.critical, Severity.high]
    assert profiles[0].rules[0].category == Category.dos
    assert profiles[0].rules[0].action.get_action_name() == "alert"
    assert profiles[0].rules[0].host == Host.client
    assert profiles[0].threat_exception[0].name == "TestException1"
    assert profiles[0].threat_exception[0].action.get_action_name() == "allow"
    assert profiles[0].threat_exception[0].exempt_ip[0].name == "192.168.1.1"


def test_create_vulnerability_protection_profile(load_env, mock_scm):
    """
    Test creating a vulnerability protection profile.
    """
    # Prepare test data
    test_profile_data = {
        "name": "NewTestProfile",
        "folder": "Prisma Access",
        "description": "A new test vulnerability protection profile",
        "rules": [
            {
                "name": "NewRule",
                "severity": ["medium", "low"],
                "category": "code-execution",
                "packet_capture": "extended-capture",
                "action": {"block_ip": {"track_by": "source", "duration": 300}},
                "host": "server",
            }
        ],
        "threat_exception": [
            {
                "name": "NewException",
                "action": "allow",
                "packet_capture": "disable",
                "exempt_ip": [{"name": "10.0.0.1"}],
                "notes": "Exception note",
            }
        ],
    }

    # Expected payload after model processing
    expected_payload = {
        "name": "NewTestProfile",
        "folder": "Prisma Access",
        "description": "A new test vulnerability protection profile",
        "rules": [
            {
                "name": "NewRule",
                "severity": ["medium", "low"],
                "category": "code-execution",
                "packet_capture": "extended-capture",
                "action": {"block_ip": {"track_by": "source", "duration": 300}},
                "host": "server",
            }
        ],
        "threat_exception": [
            {
                "name": "NewException",
                "action": {"allow": {}},
                "packet_capture": "disable",
                "exempt_ip": [{"name": "10.0.0.1"}],
                "notes": "Exception note",
            }
        ],
    }

    # Mock response from the API client
    mock_response = expected_payload.copy()
    mock_response["id"] = "333e4567-e89b-12d3-a456-426655440002"  # Mocked ID

    # Mock the API client's post method
    mock_scm.post = MagicMock(return_value=mock_response)

    # Create an instance of VulnerabilityProtectionProfile with the mocked Scm
    vuln_prot_profile_client = VulnerabilityProtectionProfile(mock_scm)

    # Call the create method
    created_profile = vuln_prot_profile_client.create(test_profile_data)

    # Assertions
    mock_scm.post.assert_called_once_with(
        "/config/security/v1/vulnerability-protection-profiles",
        json=expected_payload,
    )
    assert isinstance(created_profile, VulnerabilityProtectionProfileResponseModel)
    assert created_profile.id == "333e4567-e89b-12d3-a456-426655440002"
    assert created_profile.name == "NewTestProfile"
    assert created_profile.rules[0].name == "NewRule"
    assert created_profile.rules[0].action.get_action_name() == "block_ip"
    assert created_profile.rules[0].host == Host.server
    assert created_profile.threat_exception[0].name == "NewException"


def test_get_vulnerability_protection_profile(load_env, mock_scm):
    """
    Test retrieving a vulnerability protection profile by ID.
    """
    # Mock response from the API client
    profile_id = "123e4567-e89b-12d3-a456-426655440000"
    mock_response = {
        "id": profile_id,
        "name": "TestProfile",
        "folder": "Prisma Access",
        "description": "A test vulnerability protection profile",
        "rules": [],
        "threat_exception": [],
    }

    # Mock the API client's get method
    mock_scm.get = MagicMock(return_value=mock_response)

    # Create an instance of VulnerabilityProtectionProfile with the mocked Scm
    vuln_prot_profile_client = VulnerabilityProtectionProfile(mock_scm)

    # Call the get method
    profile = vuln_prot_profile_client.get(profile_id)

    # Assertions
    mock_scm.get.assert_called_once_with(
        f"/config/security/v1/vulnerability-protection-profiles/{profile_id}"
    )
    assert isinstance(profile, VulnerabilityProtectionProfileResponseModel)
    assert profile.id == profile_id
    assert profile.name == "TestProfile"
    assert profile.description == "A test vulnerability protection profile"


def test_update_vulnerability_protection_profile(load_env, mock_scm):
    """
    Test updating a vulnerability protection profile.
    """
    # Prepare test data
    profile_id = "123e4567-e89b-12d3-a456-426655440000"
    update_data = {
        "name": "UpdatedProfile",
        "folder": "Prisma Access",
        "description": "An updated vulnerability protection profile",
        "rules": [
            {
                "name": "UpdatedRule",
                "severity": ["high"],
                "category": "overflow",
                "packet_capture": "disable",
                "action": "drop",
                "host": "any",
                "cve": ["CVE-2021-12345"],
            }
        ],
        "threat_exception": [],
    }

    # Expected payload after model processing
    expected_payload = {
        "name": "UpdatedProfile",
        "folder": "Prisma Access",
        "description": "An updated vulnerability protection profile",
        "rules": [
            {
                "name": "UpdatedRule",
                "severity": ["high"],
                "category": "overflow",
                "packet_capture": "disable",
                "action": {"drop": {}},
                "host": "any",
                "cve": ["CVE-2021-12345"],
            }
        ],
        "threat_exception": [],
    }

    # Mock response from the API client
    mock_response = expected_payload.copy()
    mock_response["id"] = profile_id

    # Mock the API client's put method
    mock_scm.put = MagicMock(return_value=mock_response)

    # Create an instance of VulnerabilityProtectionProfile with the mocked Scm
    vuln_prot_profile_client = VulnerabilityProtectionProfile(mock_scm)

    # Call the update method
    updated_profile = vuln_prot_profile_client.update(profile_id, update_data)

    # Assertions
    mock_scm.put.assert_called_once_with(
        f"/config/security/v1/vulnerability-protection-profiles/{profile_id}",
        json=expected_payload,
    )
    assert isinstance(updated_profile, VulnerabilityProtectionProfileResponseModel)
    assert updated_profile.id == profile_id
    assert updated_profile.name == "UpdatedProfile"
    assert updated_profile.description == "An updated vulnerability protection profile"
    assert updated_profile.rules[0].action.get_action_name() == "drop"
    assert updated_profile.rules[0].host == Host.any
    assert updated_profile.rules[0].cve == ["CVE-2021-12345"]


def test_delete_vulnerability_protection_profile(load_env, mock_scm):
    """
    Test deleting a vulnerability protection profile.
    """
    # Prepare test data
    profile_id = "123e4567-e89b-12d3-a456-426655440000"

    # Mock the API client's delete method
    mock_scm.delete = MagicMock(return_value=None)

    # Create an instance of VulnerabilityProtectionProfile with the mocked Scm
    vuln_prot_profile_client = VulnerabilityProtectionProfile(mock_scm)

    # Call the delete method
    vuln_prot_profile_client.delete(profile_id)

    # Assertions
    mock_scm.delete.assert_called_once_with(
        f"/config/security/v1/vulnerability-protection-profiles/{profile_id}"
    )


def test_vulnerability_protection_profile_request_model_validation_errors():
    """
    Test validation errors in VulnerabilityProtectionProfileRequestModel.
    """
    # No container provided
    data_no_container = {
        "name": "InvalidProfile",
        "rules": [],
    }
    with pytest.raises(ValueError) as exc_info:
        VulnerabilityProtectionProfileRequestModel(**data_no_container)
    assert "Exactly one of 'folder', 'snippet', or 'device' must be provided." in str(
        exc_info.value
    )

    # Multiple containers provided
    data_multiple_containers = {
        "name": "InvalidProfile",
        "folder": "Shared",
        "device": "Device1",
        "rules": [],
    }
    with pytest.raises(ValueError) as exc_info:
        VulnerabilityProtectionProfileRequestModel(**data_multiple_containers)
    assert "Exactly one of 'folder', 'snippet', or 'device' must be provided." in str(
        exc_info.value
    )

    # Invalid action in RuleRequest
    data_invalid_action = {
        "name": "InvalidProfile",
        "folder": "Shared",
        "rules": [
            {
                "name": "InvalidRule",
                "severity": ["high"],
                "category": "botnet",
                "action": {},  # Empty action dictionary
            }
        ],
    }
    with pytest.raises(ValueError) as exc_info:
        VulnerabilityProtectionProfileRequestModel(**data_invalid_action)
    assert "Exactly one action must be provided in 'action' field." in str(
        exc_info.value
    )

    # Invalid UUID in id field (for response model)
    data_invalid_id = {
        "id": "invalid-uuid",
        "name": "TestProfile",
        "folder": "Shared",
        "rules": [],
    }
    with pytest.raises(ValueError) as exc_info:
        VulnerabilityProtectionProfileResponseModel(**data_invalid_id)
    assert "Invalid UUID format for 'id'" in str(exc_info.value)


def test_vulnerability_protection_profile_list_validation_error(load_env, mock_scm):
    """
    Test validation error when listing with multiple containers.
    """
    # Create an instance of VulnerabilityProtectionProfile with the mocked Scm
    vuln_prot_profile_client = VulnerabilityProtectionProfile(mock_scm)

    # Attempt to call the list method with multiple containers
    with pytest.raises(ValidationError) as exc_info:
        vuln_prot_profile_client.list(folder="Shared", snippet="TestSnippet")

    # Assertions
    assert "Exactly one of 'folder', 'snippet', or 'device' must be provided." in str(
        exc_info.value
    )


def test_rule_request_model_validation():
    """
    Test validation in RuleRequest model.
    """
    # Invalid severity
    data_invalid_severity = {
        "name": "TestRule",
        "severity": ["nonexistent_severity"],
        "category": "code-execution",
        "action": "alert",
    }
    with pytest.raises(ValueError) as exc_info:
        RuleRequest(**data_invalid_severity)
    assert "1 validation error for RuleRequest" in str(exc_info.value)

    # Missing action
    data_missing_action = {
        "name": "TestRule",
        "severity": ["critical"],
        "category": "dos",
    }
    rule = RuleRequest(**data_missing_action)
    assert rule.action is None


def test_threat_exception_request_model_validation():
    """
    Test validation in ThreatExceptionRequest model.
    """
    # Invalid packet_capture
    data_invalid_packet_capture = {
        "name": "TestException",
        "action": "alert",
        "packet_capture": "invalid_option",
    }
    with pytest.raises(ValueError) as exc_info:
        ThreatExceptionRequest(**data_invalid_packet_capture)
    assert "1 validation error for ThreatExceptionRequest" in str(exc_info.value)

    # Missing action
    data_missing_action = {
        "name": "TestException",
        "packet_capture": "disable",
    }
    with pytest.raises(Exception) as exc_info:
        ThreatExceptionRequest(**data_missing_action)
    assert "1 validation error for ThreatExceptionRequest" in str(exc_info.value)
    assert "action\n  Field required" in str(exc_info.value)


def test_list_vulnerability_protection_profiles_with_pagination(load_env, mock_scm):
    """
    Test listing vulnerability protection profiles with pagination parameters.
    """
    # Mock response from the API client
    mock_response = {
        "data": [
            {
                "id": "223e4567-e89b-12d3-a456-426655440001",
                "name": "TestProfile2",
                "folder": "Prisma Access",
                "rules": [],
                "threat_exception": [],
            },
        ],
        "offset": 1,
        "total": 2,
        "limit": 1,
    }

    # Mock the API client's get method
    mock_scm.get = MagicMock(return_value=mock_response)

    # Create an instance of VulnerabilityProtectionProfile with the mocked Scm
    vuln_prot_profile_client = VulnerabilityProtectionProfile(mock_scm)

    # Call the list method with pagination parameters
    profiles = vuln_prot_profile_client.list(folder="Prisma Access", offset=1, limit=1)

    # Assertions
    mock_scm.get.assert_called_once_with(
        "/config/security/v1/vulnerability-protection-profiles",
        params={"folder": "Prisma Access", "offset": 1, "limit": 1},
    )
    assert isinstance(profiles, list)
    assert len(profiles) == 1
    assert profiles[0].name == "TestProfile2"
    assert profiles[0].id == "223e4567-e89b-12d3-a456-426655440001"


def test_list_vulnerability_protection_profiles_with_name_filter(load_env, mock_scm):
    """
    Test listing vulnerability protection profiles with name filter.
    """
    # Mock response from the API client
    mock_response = {
        "data": [
            {
                "id": "223e4567-e89b-12d3-a456-426655440001",
                "name": "SpecificProfile",
                "folder": "Prisma Access",
                "rules": [],
                "threat_exception": [],
            },
        ],
        "offset": 0,
        "total": 1,
        "limit": 200,
    }

    # Mock the API client's get method
    mock_scm.get = MagicMock(return_value=mock_response)

    # Create an instance of VulnerabilityProtectionProfile with the mocked Scm
    vuln_prot_profile_client = VulnerabilityProtectionProfile(mock_scm)

    # Call the list method with name filter
    profiles = vuln_prot_profile_client.list(
        folder="Prisma Access", name="SpecificProfile"
    )

    # Assertions
    mock_scm.get.assert_called_once_with(
        "/config/security/v1/vulnerability-protection-profiles",
        params={"folder": "Prisma Access", "name": "SpecificProfile"},
    )
    assert isinstance(profiles, list)
    assert len(profiles) == 1
    assert profiles[0].name == "SpecificProfile"
    assert profiles[0].id == "223e4567-e89b-12d3-a456-426655440001"


def test_vulnerability_protection_profile_list_with_invalid_pagination(
    load_env, mock_scm
):
    """
    Test validation error when invalid pagination parameters are provided.
    """
    # Create an instance of VulnerabilityProtectionProfile with the mocked Scm
    vuln_prot_profile_client = VulnerabilityProtectionProfile(mock_scm)

    # Attempt to call the list method with invalid pagination parameters
    with pytest.raises(ValueError) as exc_info:
        vuln_prot_profile_client.list(
            folder="Prisma Access",
            offset=-1,
            limit=0,
        )

    # Assertions
    assert "Offset must be a non-negative integer" in str(exc_info.value)
    assert "Limit must be a positive integer" in str(exc_info.value)


def test_action_request_check_and_transform_action():
    """
    Test the check_and_transform_action method of ActionRequest.
    """
    # Test string input
    action = ActionRequest("alert")
    assert action.root == {"alert": {}}

    # Test dict input
    action = ActionRequest({"drop": {}})
    assert action.root == {"drop": {}}

    # Test invalid input type
    with pytest.raises(
        ValueError, match="Invalid action format; must be a string or dict."
    ):
        ActionRequest(123)

    # Test multiple actions
    with pytest.raises(
        ValueError, match="Exactly one action must be provided in 'action' field."
    ):
        ActionRequest({"alert": {}, "drop": {}})

    # Test empty dict
    with pytest.raises(
        ValueError, match="Exactly one action must be provided in 'action' field."
    ):
        ActionRequest({})


def test_action_response_check_action():
    """
    Test the check_action method of ActionResponse.
    """
    # Test string input
    action = ActionResponse("alert")
    assert action.root == {"alert": {}}

    # Test dict input
    action = ActionResponse({"drop": {}})
    assert action.root == {"drop": {}}

    # Test invalid input type
    with pytest.raises(
        ValueError, match="Invalid action format; must be a string or dict."
    ):
        ActionResponse(123)

    # Test multiple actions
    with pytest.raises(
        ValueError, match="At most one action must be provided in 'action' field."
    ):
        ActionResponse({"alert": {}, "drop": {}})

    # Test empty dict (should be allowed for ActionResponse)
    action = ActionResponse({})
    assert action.root == {}


def test_action_request_and_response_get_action_name():
    """
    Test get_action_name method for both ActionRequest and ActionResponse.
    """
    action_req = ActionRequest("alert")
    assert action_req.get_action_name() == "alert"

    action_res = ActionResponse({"drop": {}})
    assert action_res.get_action_name() == "drop"

    action_res_empty = ActionResponse({})
    assert action_res_empty.get_action_name() == "unknown"


def test_time_attribute_model_validation():
    """
    Test validation in TimeAttribute model.
    """
    # Valid data
    valid_data = {
        "interval": 60,
        "threshold": 100,
        "track_by": "source",
    }
    time_attr = TimeAttribute(**valid_data)
    assert time_attr.interval == 60
    assert time_attr.threshold == 100
    assert time_attr.track_by == TimeAttributeTrackBy.source

    # Invalid interval
    invalid_data_interval = valid_data.copy()
    invalid_data_interval["interval"] = 0
    with pytest.raises(ValueError) as exc_info:
        TimeAttribute(**invalid_data_interval)
    assert "1 validation error for TimeAttribute" in str(exc_info.value)
    assert "Input should be greater than or equal to 1" in str(exc_info.value)

    # Invalid threshold
    invalid_data_threshold = valid_data.copy()
    invalid_data_threshold["threshold"] = 70000
    with pytest.raises(ValueError) as exc_info:
        TimeAttribute(**invalid_data_threshold)
    assert "1 validation error for TimeAttribute" in str(exc_info.value)
    assert "Input should be less than or equal to 65535" in str(exc_info.value)

    # Invalid track_by
    invalid_data_track_by = valid_data.copy()
    invalid_data_track_by["track_by"] = "invalid"
    with pytest.raises(ValueError) as exc_info:
        TimeAttribute(**invalid_data_track_by)
    assert "Input should be 'source', 'destination' or 'source-and-destination'" in str(
        exc_info.value
    )


def test_action_request_non_block_ip_validation():
    """
    Test validation of non-'block_ip' actions in ActionRequest.
    """
    valid_actions = [
        "allow",
        "alert",
        "drop",
        "reset_client",
        "reset_server",
        "reset_both",
        "default",
    ]

    for action in valid_actions:
        # Test valid action (empty dict)
        valid_action = ActionRequest({action: {}})
        assert valid_action.root == {action: {}}

        # Test invalid action (non-empty dict)
        with pytest.raises(
            ValueError, match="Action '[^']+' does not take any parameters."
        ):
            ActionRequest({action: {"param": "value"}})


def test_action_request_block_ip_validation():
    """
    Test validation of 'block_ip' action in ActionRequest.
    """
    # Test valid block_ip action
    valid_block_ip = {"block_ip": {"track_by": "source", "duration": 3600}}
    action = ActionRequest(valid_block_ip)
    assert action.root == valid_block_ip

    # Test invalid block_ip action (not a dict)
    with pytest.raises(
        ValueError,
        match="'block_ip' action must be a dict with 'track_by' and 'duration' fields.",
    ):
        ActionRequest({"block_ip": "invalid"})

    # Test invalid block_ip action (missing required fields)
    with pytest.raises(ValueError, match="Invalid 'block_ip' action:"):
        ActionRequest({"block_ip": {}})

    # Test invalid block_ip action (invalid field values)
    with pytest.raises(ValueError, match="Invalid 'block_ip' action:"):
        ActionRequest({"block_ip": {"track_by": "invalid", "duration": "not_a_number"}})


def test_action_request_invalid_input():
    """
    Test invalid input for ActionRequest.
    """
    with pytest.raises(
        ValueError, match="Invalid action format; must be a string or dict."
    ):
        ActionRequest(123)

    with pytest.raises(
        ValueError, match="Exactly one action must be provided in 'action' field."
    ):
        ActionRequest({})

    with pytest.raises(
        ValueError, match="Exactly one action must be provided in 'action' field."
    ):
        ActionRequest({"allow": {}, "drop": {}})


def test_action_response_validation():
    """
    Test validation in ActionResponse.
    """
    # Test valid empty dict
    valid_empty = ActionResponse({})
    assert valid_empty.root == {}

    # Test valid actions
    valid_actions = [
        "allow",
        "alert",
        "drop",
        "reset_client",
        "reset_server",
        "reset_both",
        "default",
    ]
    for action in valid_actions:
        valid_response = ActionResponse({action: {}})
        assert valid_response.root == {action: {}}

    # Test valid block_ip action
    valid_block_ip = ActionResponse(
        {"block_ip": {"track_by": "source", "duration": 3600}}
    )
    assert valid_block_ip.root == {"block_ip": {"track_by": "source", "duration": 3600}}

    # Test invalid block_ip action (not a dict)
    with pytest.raises(
        ValueError,
        match="'block_ip' action must be a dict with 'track_by' and 'duration' fields.",
    ):
        ActionResponse({"block_ip": "invalid"})

    # Test invalid block_ip action (missing required fields)
    with pytest.raises(ValueError, match="Invalid 'block_ip' action:"):
        ActionResponse({"block_ip": {}})

    # Test invalid block_ip action (invalid field values)
    with pytest.raises(ValueError, match="Invalid 'block_ip' action:"):
        ActionResponse(
            {"block_ip": {"track_by": "invalid", "duration": "not_a_number"}}
        )

    # Test invalid non-empty dict that's not a valid action
    with pytest.raises(ValueError, match="Invalid action format."):
        ActionResponse({"invalid_action": "value"})

    # Test multiple actions
    with pytest.raises(
        ValueError, match="At most one action must be provided in 'action' field."
    ):
        ActionResponse({"allow": {}, "drop": {}})

    # Test invalid input type
    with pytest.raises(
        ValueError, match="Invalid action format; must be a string or dict."
    ):
        ActionResponse(123)

    # Test non-empty dict for non-block_ip actions
    with pytest.raises(
        ValueError, match="Action 'allow' does not take any parameters."
    ):
        ActionResponse({"allow": {"some_param": "value"}})
