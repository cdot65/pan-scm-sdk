- Core SDK logic resides in the `scm/` directory.
- Package structure within `scm/`: `client.py`, `auth.py`, `exceptions.py`, `base_object.py`, `config/` (for service classes), `models/` (for Pydantic models). Organize `config` and `models` further by category (e.g., `objects`, `network`, `deployment`).
- Place tests in `tests/` directory parallel to `scm/`, mirroring the `scm/` structure (e.g., `tests/config/objects/test_address.py`).
- Place documentation source files in `docs/`.
- Place runnable usage examples in `examples/`, mirroring the `scm/` structure where applicable.
- Use `pyproject.toml` for dependency management via Poetry.
- **Enforce `ruff`:** Use `ruff` for linting and formatting (`ruff check --fix`, `ruff format`). Configuration is in `pyproject.toml`.
- **PEP 8:** Adhere strictly to PEP 8 guidelines, enforced by `ruff`.
  - `snake_case` for functions, methods, variables.
  - `PascalCase` for classes.
  - `UPPER_CASE` for constants.
- **Line Length:** Follow `ruff format` defaults (typically 88 characters).
- **Imports:** Use `ruff`'s isort integration for import sorting. Prefer absolute imports within the `scm` package.
- **Mandatory:** Use Python 3.10+ type hints for all function/method parameters and return values.
- **Clarity:** Use standard types from `typing` (`Optional`, `List`, `Dict`, `Any`, `Union`, `Literal`, `Type`).
- **Optional Types:** Use `Optional[Type]` or the `Type | None` syntax for optional parameters/attributes.
- **Pydantic:** Leverage Pydantic models for data structure typing.
- **Unified Client:** Prioritize using and documenting the `Scm`/`ScmClient` unified client pattern (`client.address.list()`).
- **BaseObject Inheritance:** All resource service classes (e.g., `Address`, `Tag`) must inherit from `BaseObject`.
- **Standard Methods:** Implement `create`, `get`, `fetch`, `list`, `update`, `delete` consistently across resources.
- **Container Handling:** Explicitly handle and validate container arguments (`folder`, `snippet`, `device`), ensuring exactly one is used where required by the API/models.
- **Pagination:** Implement auto-pagination in `list` methods using `max_limit`.
- **Filtering:** Support both API-level filtering (via `params`) and client-side filtering (`exact_match`, `exclude_*`).
- **Modularity:** Keep resource logic encapsulated within its respective service class and model files.
- **Pydantic V2:** Utilize Pydantic V2+ features.
- **Specific Models:** Define distinct `CreateModel`, `UpdateModel`, and `ResponseModel` for each resource type. Use a `BaseModel` for shared fields.
- **Validation:** Use `Field` for basic validation (length, regex). Implement custom validators (`@field_validator`, `@model_validator`) for complex rules (e.g., container exclusivity, address type exclusivity, schedule format).
- **Serialization:** Use `.model_dump(exclude_unset=True)` when preparing payloads for API calls to avoid sending default values.
- **Clarity:** Define models in dedicated files within the `scm/models/` directory, organized by resource category.
- **Core Libraries:** Use `requests` for HTTP calls and `requests_oauthlib` for OAuth2 handling.
- **Authentication Flow:** Implement OAuth2 Client Credentials flow within `auth.py`.
- **Token Management:** Ensure robust automatic token refresh logic within the `OAuth2Client` and its integration into the main `Scm` client. Handle potential refresh failures gracefully.
- **Centralized Requests:** Route all API calls through standardized methods in the `Scm` client (`_get`, `_post`, etc.) which handle auth and base error checking.
- **Configuration:** Support custom `token_url` and `base_url` during client initialization.
- **Custom Exceptions:** Use the defined exception hierarchy rooted in `APIError` (`scm/exceptions.py`).
- **Specificity:** Raise specific exceptions (e.g., `ObjectNotPresentError`, `NameNotUniqueError`) based on API responses.
- **`ErrorHandler`:** Utilize the `ErrorHandler` class to map HTTP status codes and API error details to the correct custom exceptions.
- **Informative Errors:** Ensure exceptions contain relevant details (`message`, `error_code`, `http_status_code`, `details`).
- **Usage:** Implement `try...except` blocks in examples and potentially within higher-level SDK methods to catch specific SDK exceptions.
- **Framework:** Use `pytest` for all tests.
- **Coverage:** Aim for >80% code coverage, tracked via `coverage.py` and Codecov.
- **Unit Tests:** Create comprehensive unit tests for:
    - Pydantic model validation (valid and invalid inputs).
    - Authentication logic (mocking external calls).
    - Client methods (mocking `requests`).
    - `BaseObject` methods.
    - Individual resource service methods.
    - `ErrorHandler` logic.
- **Integration Tests:** Implement integration tests verifying key API interactions (consider mocking, VCR/cassettes, or a dedicated test tenant).
- **Fixtures:** Use `pytest` fixtures for setup (e.g., mock clients, reusable data).
- **Docstrings:** Write clear Google-style docstrings for all public classes, methods, and functions.
- **API Reference:** Generate API docs automatically using MkDocs with `mkdocstrings`.
- **User Guides:** Maintain core user docs: README, Installation, Getting Started, Troubleshooting, Release Notes.
- **Resource Docs:** Create dedicated pages for each resource's service class (`config/`) and models (`models/`).
- **Examples:** Provide runnable examples in the `examples/` directory and concise snippets in the documentation.
- **Hosting:** Deploy documentation using GitHub Pages.
- **Poetry:** Use Poetry for all dependency management, environment locking, and packaging.
- **`pyproject.toml`:** Define all project metadata, dependencies, and tool configurations here.
- **Pinning:** Pin direct dependencies in `pyproject.toml`. `poetry.lock` ensures locked transitive dependencies.
- **Minimalism:** Keep external dependencies to a necessary minimum.
- **Publishing:** Use Poetry to build and publish to PyPI.
- **Version Control:** Use Git with a Feature Branch workflow.
- **Pull Requests:** Require Pull Requests for merging to `main`, including reviews.
- **Pre-commit:** Use pre-commit hooks to enforce quality checks (ruff format, ruff check) before committing.
- **CI/CD:** Implement GitHub Actions for automated testing, linting, coverage reporting, and potentially documentation deployment/PyPI publishing.
- **Versioning:** Follow Semantic Versioning (SemVer).
- **Changelog:** Maintain a `CHANGELOG.md` or use `release-notes.md`.
